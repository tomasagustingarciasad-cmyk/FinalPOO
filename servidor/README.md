# Servidor RPC para Control de Brazo Rob√≥tico# Servidor RPC para Control de Robot



## üìñ Descripci√≥n## Descripci√≥n



Servidor XML-RPC en C++ que proporciona una API de control remoto para un brazo rob√≥tico Arduino. Implementa comunicaci√≥n serial (G-code/M-code) y expone m√©todos RPC para integraci√≥n con clientes web.Servidor XML-RPC que permite controlar un brazo rob√≥tico mediante protocolo G-code/M-code a trav√©s de puerto serie.



## üèóÔ∏è Arquitectura## Cumplimiento de Requerimientos del TP



```### ‚úÖ Requerimientos del Profesor (Email)

Cliente Web (Node.js) ‚óÑ‚îÄ‚îÄXML-RPC‚îÄ‚îÄ‚ñ∫ Servidor C++ ‚óÑ‚îÄ‚îÄSerial‚îÄ‚îÄ‚ñ∫ Arduino (Firmware)

     Puerto 3000              Puerto 8080         115200 baud      /dev/ttyUSB01. **Lazo de espera para descartar mensaje inicial**: Implementado en `discardInitialBanner()` con loop de 3 segundos

```2. **Descarte de respuestas "OK"**: Implementado en `readMultiLineResponse()` 

3. **Manejo de respuestas de 1 l√≠nea y multil√≠nea**:

## ‚öôÔ∏è Caracter√≠sticas Principales   - M119 (endstops): 1 l√≠nea

   - M114 (posici√≥n): m√∫ltiples l√≠neas (modo, posici√≥n, motores, fan)

- ‚úÖ **8 M√©todos RPC** (connectRobot, disconnectRobot, setMode, enableMotors, home, move, endEffector, getPosition, getEndstops)4. **Ventanas de idle**: 600ms para M114, 300ms para M119

- ‚úÖ **Comunicaci√≥n Serial Robusta** con acumulaci√≥n car√°cter a car√°cter y timeouts inteligentes

- ‚úÖ **Parsing Multi-l√≠nea** con filtrado autom√°tico de respuestas "OK"### ‚úÖ M√©todos RPC Implementados

- ‚úÖ **Thread-Safe** mediante mutexes para operaciones concurrentes

- ‚úÖ **Descarte Autom√°tico** de banner inicial del firmwareTodos los m√©todos obligatorios del TP:

- ‚úÖ **Tolerancia a Fallos** con parsing flexible y detecci√≥n de cambios de estado

- `connectRobot(port, baudrate)` - Conecta al robot y descarta banner inicial

## üöÄ Inicio R√°pido- `disconnectRobot()` - Cierra la conexi√≥n

- `setMode(manual, absolute)` - Configura modo absoluto/relativo (G90/G91)

### Compilaci√≥n- `enableMotors(enabled)` - Habilita/deshabilita motores (M17/M18)

```bash- `home()` - Ejecuta homing (G28)

cd servidor- `move(x, y, z, feedrate)` - Movimiento a coordenadas (G0/G1)

make clean && make- `endEffector(enabled)` - Activa/desactiva efector final (M106/M107)

```

M√©todos adicionales:

### Ejecuci√≥n

```bash- `getPosition()` - Consulta posici√≥n actual (M114) con parseo multil√≠nea

./servidor 8080- `getEndstops()` - Consulta estado de endstops (M119)

```

### ‚úÖ Arquitectura

### Ejemplo de Uso (Python)

```python- **Servidor**: XML-RPC sobre HTTP (puerto 8080)

import xmlrpc.client- **Comunicaci√≥n Serial**: POSIX termios, baudrate configurable

- **Thread-Safety**: Mutex para protecci√≥n de acceso al puerto serie

server = xmlrpc.client.ServerProxy('http://localhost:8080')- **Parseo Robusto**: Manejo de respuestas fragmentadas, timeouts configurables

- **Tolerancia a Fallos**: Parseo tolerante cuando datos no est√°n disponibles

# Conectar al robot

server.connectRobot('/dev/ttyUSB0', 115200)## Compilaci√≥n



# Habilitar motores y hacer homing```bash

server.enableMotors(True)cd servidor

server.home()make

```

# Mover a posici√≥n

server.move(100.0, 120.0, 50.0, 800)## Ejecuci√≥n



# Consultar estado```bash

pos = server.getPosition()# Terminal 1: Levantar servidor

print(f"Posici√≥n: X={pos['x']}, Y={pos['y']}, Z={pos['z']}")./servidor 8080

print(f"Modo: {pos['mode']}, Motores: {pos['motorsEnabled']}")

# Terminal 2: Ejecutar tests

# Desconectarpython3 test_debug.py

server.disconnectRobot()python3 test_robot_multiline.py

``````



## üì° M√©todos RPC## Tests



| M√©todo | Par√°metros | Descripci√≥n |### test_debug.py

|--------|------------|-------------|Test b√°sico que verifica:

| `connectRobot` | `port, baudrate` | Conecta al puerto serial |- Conexi√≥n al robot

| `disconnectRobot` | - | Cierra conexi√≥n serial |- Consulta de posici√≥n (M114)

| `setMode` | `mode` ("ABSOLUTE"/"RELATIVE") | Cambia sistema de coordenadas |- Consulta de endstops (M119)

| `enableMotors` | `enable` (bool) | Activa/desactiva motores |- Desconexi√≥n

| `home` | - | Ejecuta homing (G28) |

| `move` | `x, y, z, feedrate` | Movimiento coordenado |### test_robot_multiline.py

| `endEffector` | `enable` (bool) | Controla gripper/fan |Test completo que verifica:

| `getPosition` | - | Consulta posici√≥n y estados ‚≠ê |- Conexi√≥n y configuraci√≥n

| `getEndstops` | - | Estado de finales de carrera ‚≠ê |- Homing (G28)

- Movimientos m√∫ltiples

‚≠ê = M√©todos con respuesta multi-l√≠nea- Control de efector final

- Detecci√≥n de cambios de estado (motores, fan)

## üîß Configuraci√≥n del Firmware- Consultas de posici√≥n y endstops



**`Firmware/robotArm_v0.62sim/config.h`**:## Notas sobre Simulaci√≥n

```cpp

#define BAUD 115200El firmware en modo `SIMULATION=true` no actualiza las coordenadas X/Y/Z/E durante los movimientos, ya que no hay actuadores f√≠sicos. Sin embargo:

#define SIMULATION true

#define USE_ESP8266 false- ‚úÖ Los comandos de movimiento se env√≠an correctamente

```- ‚úÖ El firmware acepta y procesa los comandos

- ‚úÖ M114 parsea correctamente la respuesta multil√≠nea

Para subir el firmware:- ‚úÖ Los estados disponibles se detectan correctamente (modo, motores, fan)

1. Abrir `Firmware/robotArm_v0.62sim/robotArm_v0.62sim.ino` en Arduino IDE

2. Seleccionar **Tools ‚Üí Board ‚Üí Arduino Uno/Mega**Con hardware real, las coordenadas se actualizar√≠an despu√©s de cada movimiento.

3. Seleccionar **Tools ‚Üí Port ‚Üí /dev/ttyUSB0**

4. Click **Upload** (Ctrl+U)## Funcionalidades Destacadas



## üìÇ Estructura del Proyecto1. **Parseo Multil√≠nea Robusto**: Implementa ventanas de idle para determinar cu√°ndo termin√≥ la respuesta multil√≠nea

2. **Manejo de Fragmentaci√≥n**: El m√©todo `readLine()` acumula caracteres correctamente incluso cuando llegan fragmentados

```3. **Descarte Autom√°tico**: Filtra autom√°ticamente respuestas "OK" y banner inicial

servidor/4. **Detecci√≥n de Estado**: Parsea informaci√≥n de modo, motores y fan desde la respuesta M114

‚îú‚îÄ‚îÄ main_servidor.cpp          # Punto de entrada5. **Tolerancia a Fallos**: Retorna √©xito aunque algunos datos no est√©n disponibles (coordenadas en simulaci√≥n)

‚îú‚îÄ‚îÄ inc/

‚îÇ   ‚îú‚îÄ‚îÄ Robot.h               # Interfaz de comunicaci√≥n con firmware## Estructura del C√≥digo

‚îÇ   ‚îú‚îÄ‚îÄ SerialPort.h          # Comunicaci√≥n serial POSIX

‚îÇ   ‚îî‚îÄ‚îÄ ServerModel.h         # Definici√≥n de m√©todos RPC```

‚îú‚îÄ‚îÄ lib/servidor/

‚îÇ   ‚îú‚îÄ‚îÄ Robot.cpp             # L√≥gica de control del robot‚îú‚îÄ‚îÄ main_servidor.cpp      # Punto de entrada

‚îÇ   ‚îú‚îÄ‚îÄ SerialPort.cpp        # Implementaci√≥n serial‚îú‚îÄ‚îÄ inc/

‚îÇ   ‚îî‚îÄ‚îÄ XmlRpc*.cpp           # Librer√≠a XML-RPC‚îÇ   ‚îú‚îÄ‚îÄ Robot.h           # Interfaz de control del robot

‚îî‚îÄ‚îÄ Makefile‚îÇ   ‚îú‚îÄ‚îÄ SerialPort.h      # Comunicaci√≥n serie POSIX

```‚îÇ   ‚îî‚îÄ‚îÄ ServerModel.h     # M√©todos RPC

‚îú‚îÄ‚îÄ lib/

## üõ†Ô∏è Implementaci√≥n T√©cnica‚îÇ   ‚îú‚îÄ‚îÄ Robot.cpp         # Implementaci√≥n con parseo multil√≠nea

‚îÇ   ‚îú‚îÄ‚îÄ SerialPort.cpp    # Manejo robusto de lectura serie

### Manejo de Respuestas Multi-l√≠nea‚îÇ   ‚îî‚îÄ‚îÄ XmlRpc*.cpp       # Librer√≠a XML-RPC

‚îî‚îÄ‚îÄ test_*.py             # Scripts de prueba

El servidor implementa "ventanas de inactividad" (idle windows) para detectar el fin de respuestas multi-l√≠nea:```



```cpp## Autor

std::string readMultiLineResponse(int timeoutMs, int idleWindowMs) {

    std::string fullResponse;Implementado como parte del Trabajo Final de POO - 2025

    auto lastDataTime = std::chrono::steady_clock::now();
    
    while (true) {
        std::string line;
        if (serial_.readLine(line, 100)) {
            if (line == "OK") continue;  // Filtrar autom√°ticamente
            fullResponse += line + "\n";
            lastDataTime = std::chrono::steady_clock::now();
        }
        
        auto elapsed = millisSince(lastDataTime);
        if (elapsed >= idleWindowMs) break;  // No hay m√°s datos
    }
    return fullResponse;
}
```

**Estrategia**:
- **M114** (4-5 l√≠neas): Idle window de 600ms
- **M119** (1 l√≠nea): Idle window de 300ms
- **Filtrado autom√°tico** de l√≠neas "OK"

### Comunicaci√≥n Serial Robusta

Acumulaci√≥n car√°cter a car√°cter con reset de timeout:

```cpp
bool SerialPort::readLine(std::string& line, int timeoutMs) {
    auto start = std::chrono::steady_clock::now();
    
    while (true) {
        struct timeval tv = {0, 10000};  // 10ms timeout
        int ret = select(fd_ + 1, &readfds, nullptr, nullptr, &tv);
        
        if (ret > 0) {
            char c;
            if (read(fd_, &c, 1) > 0) {
                if (c == '\n') return true;
                if (c != '\r') line += c;
                start = std::chrono::steady_clock::now();  // Reset
            }
        }
        
        if (millisSince(start) >= timeoutMs) break;
    }
    return false;
}
```

### Thread-Safety

```cpp
class Robot {
private:
    SerialPort serial_;
    std::mutex serialMutex_;
    
public:
    RobotPosition getPosition() {
        std::lock_guard<std::mutex> lock(serialMutex_);
        // Operaciones seguras sobre serial_
    }
};
```

## üß™ Validaci√≥n

### Test de Cambio de Estado (Evidencia de Parsing Correcto)

```python
# Activar efector
server.endEffector(True)
pos1 = server.getPosition()
print(pos1['fanEnabled'])  # ‚Üí 1

# Desactivar efector
server.endEffector(False)
pos2 = server.getPosition()
print(pos2['fanEnabled'])  # ‚Üí 0 ‚úÖ Cambio detectado
```

**Conclusi√≥n**: La detecci√≥n de cambios de estado (fan ON‚ÜíOFF, motores, modo) demuestra que el parsing multi-l√≠nea funciona correctamente.

## ‚ö†Ô∏è Notas sobre Modo Simulaci√≥n

El firmware est√° en modo simulaci√≥n (`SIMULATION=true`):

- ‚úÖ **Detecci√≥n de estados**: Fan, motores, modo ‚Üí Funciona correctamente
- ‚úÖ **Comandos**: Todos los comandos se ejecutan sin errores
- ‚ö†Ô∏è **Coordenadas**: Permanecen en 0.0 (no hay actuadores f√≠sicos)

**Esto es comportamiento esperado**. Para ver coordenadas reales:
1. Conectar hardware (motores + endstops)
2. Cambiar `SIMULATION` a `false` en `config.h`
3. Recompilar y subir firmware

## üìä Resumen de Cumplimiento

| Requisito | Estado |
|-----------|--------|
| M√©todos RPC obligatorios (7) | ‚úÖ |
| M√©todos adicionales (2) | ‚úÖ |
| Descarte de banner inicial | ‚úÖ |
| Filtrado de respuestas "OK" | ‚úÖ |
| Manejo de respuestas multi-l√≠nea | ‚úÖ |
| Parsing tolerante | ‚úÖ |
| Thread-safety | ‚úÖ |
| Validaci√≥n completa | ‚úÖ |

## üìö Documentaci√≥n Detallada

Para informaci√≥n t√©cnica completa (arquitectura, protocolo G-code, detalles de implementaci√≥n, troubleshooting), consultar:

**`DOCUMENTACION_TECNICA.md`** - Documentaci√≥n exhaustiva con:
- Requisitos del profesor y su implementaci√≥n
- Protocolo de comunicaci√≥n completo
- Detalles de implementaci√≥n cr√≠ticos
- Logs de pruebas y validaci√≥n
- Notas de debugging y decisiones de dise√±o

## üë§ Autor

Trabajo Final - Programaci√≥n Orientada a Objetos 2025
